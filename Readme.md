# Black Sphere simulation data db

The goal of this project was to create database using PostgressSQL, for managing data of Black Spheres project.
Main files:
* main.py - script creating database from simulation_result.csv - changing into a class in progress
* simulation_result.csv - results of the simulation generated by Matlab Multibody simulation - format: (id, k, l, m, d, rotation_x, rotation_y, rotation_z, timve vector)

## Preliminaries
Before usage of the script, create database using psql or other method, but with the PostgreSQL dialect.
Required database name: new_database
Create also user with the login: engineer1 , and password:1234.

## Code
Defining Tables and relations between them:
```# definition of the class representation
class K_param(base):
    __tablename__ = "k_param"
    id = Column(Integer, Sequence("k_param_id"), primary_key=True)
    unit = Column("unit", String(10))
    value = Column("value", Double)
    results = relationship("Results", back_populates="k_param")

    def __init__(self, value, unit):
        self.value = value
        self.unit = unit


class L_param(base):
    __tablename__ = "l_param"
    id = Column(Integer, Sequence("l_param_id"), primary_key=True)
    unit = Column("unit", String(10))
    value = Column("value", Double)
    results = relationship("Results", back_populates="l_param")

    def __init__(self, value, unit):
        self.value = value
        self.unit = unit

class M_param(base):
    __tablename__ = "m_param"
    id = Column(Integer, Sequence("m_param_id"), primary_key=True)
    unit = Column("unit", String(10))
    value = Column("value", Double)
    results = relationship("Results", back_populates="m_param")

    def __init__(self, value, unit):
        self.value = value
        self.unit = unit

class D_param(base):
    __tablename__ = "d_param"
    id = Column(Integer, Sequence("d_param_id"), primary_key=True)
    unit = Column("unit", String(10))
    value = Column("value", Double)
    results = relationship("Results", back_populates="d_param")

    def __init__(self, value, unit):
        self.value = value
        self.unit = unit


class Results(base):
    __tablename__ = "results"
    id      = Column(Integer, Sequence("result_id"), primary_key=True)

    k_id    = Column(Integer, ForeignKey("k_param.id"))
    l_id    = Column(Integer, ForeignKey("l_param.id"))
    d_id    = Column(Integer, ForeignKey("d_param.id"))
    m_id    = Column(Integer, ForeignKey("m_param.id"))

    k_param = relationship("K_param", back_populates="results")
    l_param = relationship("L_param", back_populates="results")
    d_param = relationship("D_param", back_populates="results")
    m_param = relationship("M_param", back_populates="results")

    simulation_real_id = Column("simulation_real_id", Integer)

    rot_x   = Column("rot_x", Text)
    rot_y   = Column("rot_y", Text)
    rot_z   = Column("rot_z", Text)

    t_vec   = Column("t_vec", Text)

    def __init__(self, rot_x, rot_y, rot_z, t_vec):
        self.rot_x = rot_x
        self.rot_y = rot_y
        self.rot_z = rot_z

        self.t_vec = t_vec
```
Database consists of 5 main tables:
* K_param - Spring coefficient used in the simulation(id, value, unit)
* L_param - Natural length of the spring used in the simulation(id, value, unit)
* M_param - Mass on a spring used in the simulation(id, value, unit)
* D_param - Damping coefficient of the spring-mass connection in the simulation(id, value, unit)
* Results - Results of the simulation - rotation along x,y,z axes and time vector in the string, where each elem is separated with the space sign.

The relationship looks like this:
* K_param - Results - One to Many(K_param - parent)
* L_param - Results - One to Many(K_param - parent)
* M_param - Results - One to Many(K_param - parent)
* D_param - Results - One to Many(K_param - parent)

Parsing data to tables:
```# read data from csv
# Data format:
# ID:int, K:int, L:int, M:int, D:int, Rot_x:string, Rot_y:string, Rot_z:string, T_vec:string
# ID - id of simulation
# K - Spring coefficient
# L - natural length of spring
# M - mass of the weight
# D - damping coefficient
# Rot_x - vector of rotation of sphere around x axis
# Rot_y - vector of rotation of sphere around y axis
# Rot_z - vector of rotation of sphere around z axis
# t_vec - time vector of simulation

results_df = pd.read_csv("simulation_result.csv", nrows=30)
results_df.columns = results_df.columns.str.replace(" ", "")

results_df.fillna("")

results_df = results_df.rename(columns= {"k" : "k_param", "l" : "l_param", "m" : "m_param", "d" : "d_param", "id" : "simulation_real_id"})

# K-param table
k_list = pd.DataFrame(results_df["k_param"]).drop_duplicates().reset_index().drop(columns = ["index"])
k_list = k_list.rename(columns = {"k_param" : "value"})

unit_list = ["N/m"]*k_list.shape[0]
k_list["unit"] = unit_list
k_list.index.name = "id"

# L-param table
l_list = pd.DataFrame(results_df["l_param"]).drop_duplicates().reset_index().drop(columns = ["index"])
l_list = l_list.rename(columns = {"l_param" : "value"})

unit_list = ["mm"]*l_list.shape[0]
l_list["unit"] = unit_list
l_list.index.name = "id"

# M-param table
m_list = pd.DataFrame(results_df["m_param"]).drop_duplicates().reset_index().drop(columns = ["index"])
m_list = m_list.rename(columns = {"m_param" : "value"})

unit_list = ["g"]*m_list.shape[0]
m_list["unit"] = unit_list
m_list.index.name = "id"

# D-param table
d_list = pd.DataFrame(results_df["d_param"]).drop_duplicates().reset_index().drop(columns = ["index"])
d_list = d_list.rename(columns = {"d_param" : "value"})

d_list["value"] = d_list["value"].astype(float)[0]

unit_list = ["Ns^2/m"]*d_list.shape[0]
d_list["unit"] = unit_list
d_list.index.name = "id"


list_of_points_z = string_to_array(results_df['rot_z'][0])
list_of_points_t = string_to_array(results_df['t_vec'][0])

# results table
results_list = results_df.rename(columns= {"k_param" : "k_id", "l_param" : "l_id", "m_param" : "m_id", "d_param" : "d_id"})

temp_list = ["k_id", "l_id", "m_id", "d_id"]
handle_list = [k_list, l_list, m_list, d_list]

for i in range(len(temp_list)):
    col = temp_list[i]
    handle = handle_list[i]
    temp_string = "value"
    results_list[col] = results_list[col].map(lambda x: handle[handle[temp_string] == x].index.values.astype(int)[0])

results_list.index.name = "id"


handle_list.append(results_list)

table_names_list = ["k_param", "l_param", "m_param", "d_param", "results"]
```

Example Query result:
```
    print("Query using select statement - mapper for columns table:")
    stmt = select(tables_dict['l_param'].c.value, tables_dict['l_param'].c.id)
    print("Used statement:")
    print(stmt)
    print("Returned table:")
    results_stmt = conn.execute(stmt).fetchall()

    print(results_stmt)
```
Result:
```    
Query using select statement - mapper for columns table:
Used statement:
SELECT l_param.value, l_param.id 
FROM l_param
Returned table:
[(15.0, 0), (20.0, 1), (30.0, 2), (40.0, 3)]
```

Example of query with plotting of results from database:
```
    print("Example of ploting results from database:")
    text_stmt = text("""select results.t_vec, results.rot_z, l_param.value, m_param.value, k_param.value  from results\n""" +
                      """inner join m_param\n""" +
                      """on m_param.id = results.m_id\n""" +
                      """inner join l_param\n""" +
                      """on l_param.id = results.l_id\n""" +
                      """inner join k_param\n""" +
                      """on k_param.id = results.k_id\n""" +
                      """where l_param.value = 15 and m_param.value = 50;"""
                     )
    print(text_stmt)

    results_stmt = conn.execute(text_stmt).fetchall()
    lines = []
    for result_elem in results_stmt:
        time_vec = string_to_array(result_elem[0])
        rot_z = string_to_array(result_elem[1])
        l_value = result_elem[2]
        m_value = result_elem[3]
        k_value = result_elem[4]
        label_to_write = "k = " + str(k_value) + " l = " + str(l_value) + " m_value = " + str(m_value)

        line = plt.plot(time_vec, rot_z, label=label_to_write)
        plt.xlabel("Time")
        plt.ylabel("Rotation(rad/s)")
        lines.append(label_to_write)
    plt.legend(lines)
    plt.show()
```
![Not loaded  ¯\_(ツ)_/¯](result_figure.png  "¯\_(ツ)_/¯")